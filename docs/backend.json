{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the AvatarTalk application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        },
        "planId": {
          "type": "string",
          "description": "The user's current subscription plan.",
          "enum": ["free", "hobbyist", "creator"]
        },
        "subscriptionTier": {
            "type": "string",
            "description": "The billing cycle for the subscription.",
            "enum": ["monthly", "yearly"]
        },
        "subscriptionStartDate": {
            "type": "string",
            "description": "The start date of the current subscription period.",
            "format": "date-time"
        },
        "subscriptionEndDate": {
            "type": "string",
            "description": "The end date of the current subscription period.",
            "format": "date-time"
        },
        "creditsUsed": {
            "type": "number",
            "description": "The number of characters used in the current billing cycle."
        },
        "creditsRemaining": {
            "type": "number",
            "description": "The number of characters remaining in the current billing cycle."
        },
        "lastCreditRenewalDate": {
            "type": "string",
            "description": "The last date the user's credits were renewed.",
            "format": "date-time"
        },
        "lastEmotionUseDate": {
          "type": "string",
          "description": "The last date a free tier user used a custom emotion.",
          "format": "date-time"
        },
        "referralCode": {
          "type": "string",
          "description": "The unique referral code assigned to the user."
        },
        "referredBy": {
          "type": "string",
          "description": "Reference to the User that referred this user. (Relationship: User 1:N User)"
        },
        "creationDate": {
          "type": "string",
          "description": "The date and time when the user account was created.",
          "format": "date-time"
        },
        "lastKnownIp": {
            "type": "string",
            "description": "The last known IP address of the user."
        }
      },
      "required": [
        "id",
        "email",
        "planId",
        "referralCode",
        "creationDate"
      ]
    },
    "Avatar": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Avatar",
      "type": "object",
      "description": "Represents a user's avatar in the AvatarTalk application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Avatar entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User that owns this avatar. (Relationship: User 1:N Avatar)"
        },
        "photoUrl": {
          "type": "string",
          "description": "URL of the photo used for the avatar.",
          "format": "uri"
        },
        "creationDate": {
          "type": "string",
          "description": "The date and time when the avatar was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "photoUrl",
        "creationDate"
      ]
    },
    "GeneratedVideo": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GeneratedVideo",
      "type": "object",
      "description": "Represents a generated video using the AvatarTalk application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the GeneratedVideo entity."
        },
        "avatarId": {
          "type": "string",
          "description": "Reference to the Avatar used to generate this video. (Relationship: Avatar 1:N GeneratedVideo)"
        },
        "audioUrl": {
          "type": "string",
          "description": "URL of the audio used to generate the video.",
          "format": "uri"
        },
        "videoUrl": {
          "type": "string",
          "description": "URL of the generated video.",
          "format": "uri"
        },
        "generationDate": {
          "type": "string",
          "description": "The date and time when the video was generated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "avatarId",
        "audioUrl",
        "videoUrl",
        "generationDate"
      ]
    },
    "Notification": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Notification",
      "type": "object",
      "description": "Represents a message sent from an admin to a user or all users.",
      "properties": {
        "id": { "type": "string", "description": "Unique ID for the notification." },
        "recipient": { "type": "string", "description": "The ID of the recipient user, or 'all' for a broadcast message." },
        "title": { "type": "string", "description": "The title of the notification." },
        "message": { "type": "string", "description": "The content of the notification message." },
        "read": { "type": "boolean", "description": "Whether the user has read the notification. This applies to user-specific notifications." },
        "createdAt": { "type": "string", "format": "date-time", "description": "The date and time the notification was created." }
      },
      "required": ["id", "recipient", "title", "message", "createdAt"]
    },
    "FraudAttempt": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FraudAttempt",
      "type": "object",
      "description": "Logs a detected attempt to circumvent free tier limitations.",
      "properties": {
        "id": { "type": "string", "description": "Unique ID for the fraud attempt log." },
        "email": { "type": "string", "description": "The email address used in the sign-up attempt.", "format": "email" },
        "ipAddress": { "type": "string", "description": "The IP address of the user at the time of the attempt." },
        "deviceFingerprint": { "type": "string", "description": "A unique hash representing the user's device." },
        "reason": { "type": "string", "description": "The reason the attempt was flagged.", "enum": ["vpn_detected", "duplicate_device", "duplicate_ip"] },
        "timestamp": { "type": "string", "format": "date-time", "description": "The date and time of the detected attempt." }
      },
      "required": ["id", "email", "ipAddress", "deviceFingerprint", "reason", "timestamp"]
    }
  },
  "auth": {
    "providers": [
      "password"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles. Access is controlled by the user's ID. Includes 'referralCode' and 'referredBy' for the referral program.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/avatars/{avatarId}",
        "definition": {
          "entityName": "Avatar",
          "schema": {
            "$ref": "#/backend/entities/Avatar"
          },
          "description": "Stores avatars owned by a specific user. Access is restricted to the owning user.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user."
            },
            {
              "name": "avatarId",
              "description": "The unique ID of the avatar."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/avatars/{avatarId}/generatedVideos/{generatedVideoId}",
        "definition": {
          "entityName": "GeneratedVideo",
          "schema": {
            "$ref": "#/backend/entities/GeneratedVideo"
          },
          "description": "Stores generated videos associated with a specific avatar. Access is restricted to the user who owns the avatar.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user."
            },
            {
              "name": "avatarId",
              "description": "The unique ID of the avatar."
            },
            {
              "name": "generatedVideoId",
              "description": "The unique ID of the generated video."
            }
          ]
        }
      },
      {
        "path": "/notifications/{notificationId}",
        "definition": {
          "entityName": "Notification",
          "schema": {
            "$ref": "#/backend/entities/Notification"
          },
          "description": "Stores notifications for users. Can be broadcast ('all') or user-specific.",
          "params": [
            { "name": "notificationId", "description": "The unique ID of the notification." }
          ]
        }
      },
      {
        "path": "/fraudAttempts/{attemptId}",
        "definition": {
          "entityName": "FraudAttempt",
          "schema": {
            "$ref": "#/backend/entities/FraudAttempt"
          },
          "description": "Logs suspicious sign-up attempts for admin review.",
          "params": [
            { "name": "attemptId", "description": "The unique ID for the logged attempt." }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to ensure security, scalability, and ease of debugging, while adhering to the principles of Authorization Independence, Clarity of Intent, DBAC (Database-Based Access Control), and QAPs (Rules are not Filters).  Authorization independence is achieved by avoiding `get()` calls in the rules, which requires denormalizing authorization data when needed.\n\n**Users Collection:** Stores user profiles.  A flat collection simplifies user management and authentication.  No denormalization is needed here as access control is based on `request.auth.uid`.\n\n**Avatars Subcollection:** Each user has a subcollection of Avatars.  This enforces ownership, making rules simpler and more secure.  Access control is based on the path `/users/{userId}/avatars/{avatarId}`.\n\n**GeneratedVideos Subcollection:** Each avatar has a subcollection of generated videos. This structure ensures that videos are directly associated with their avatars, and indirectly, with the user who owns the avatar. Access control is based on the path `/users/{userId}/avatars/{avatarId}/generatedVideos/{generatedVideoId}`.\n\n**Referral Program:**  The referral program is implemented directly in the `users` collection via the `referralCode` and `referredBy` fields.  This simplifies the data model and reduces the need for additional collections.\n\n**Notifications Collection:** A top-level 'notifications' collection is added to store messages. This allows admins to easily send broadcast messages to all users (by setting 'recipient' to 'all') or target specific users. Users can read broadcast messages and any messages where they are the recipient, but cannot write to the collection. This centralizes announcements and alerts.\n\n**FraudAttempts Collection:** A top-level collection to log potential fraudulent activities, like signing up from a VPN or using the same device for multiple free accounts. This collection is write-only for the backend function and read-only for admins, ensuring a secure audit trail."
  }
}

    