/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All data, including user profiles,
 * avatars, generated videos, and TTS requests are considered private and only accessible by the authenticated user who owns it.
 * There is no public or shared data.
 *
 * Data Structure: The data is organized hierarchically where applicable. User-generated content is tied to the
 * /users/{userId} path. This structure makes ownership-based security rules simple and performant.
 *
 * Key Security Decisions:
 * - User Enumeration is explicitly prevented by disallowing `list` operations on the top-level `/users` collection, except for admins.
 * - All user-specific data can only be read or written to by the owning user.
 * - The default security posture is deny-all. Access is only granted through specific `allow` rules.
 * - Input validation is enforced, such as character limits on TTS requests, to prevent abuse.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for improved readability and reusability.

    /**
     * Checks if the request is from an authenticated user.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if the user has an 'admin' custom claim.
     * In a real app, this should be managed securely via a backend process.
     */
    function isAdmin() {
      return isSignedIn() && request.auth.token.admin == true;
    }

    // Prototyping Validation: Functions to enforce relational integrity and business logic.

    /**
     * Validates that the user document being created has its internal 'id'
     * field correctly set to match the document's path ID.
     */
    function hasValidUserCreateData(userId) {
      return request.resource.data.id == userId;
    }
    
    /**
     * Validates the required fields for a notification document upon creation.
     */
    function hasValidNotificationCreateData() {
      let data = request.resource.data;
      return data.recipient != null &&
             data.title is string && data.title.size() > 0 &&
             data.message is string && data.message.size() > 0;
    }

    /**
     * Validates a new TTS request document.
     * CRITICAL: Enforces character limit on the input text to prevent billing abuse.
     */
    function hasValidTtsRequestCreateData(userId) {
        let data = request.resource.data;
        return data.userId == userId &&
               data.text is string &&
               data.text.size() > 0 &&
               data.text.size() <= 500 && // Max 500 characters
               data.createdAt == request.time;
    }


    /**
     * @description Controls access to a user's own profile document.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get, update, delete: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if (isOwner(userId) && hasValidUserCreateData(userId)) || isAdmin();
    }
    
    /**
     * @description Controls access to notifications.
     * @path /notifications/{notificationId}
     */
    match /notifications/{notificationId} {
        allow create: if isAdmin() && hasValidNotificationCreateData();
        allow read: if isSignedIn() && (resource.data.recipient == 'all' || resource.data.recipient == request.auth.uid);
        allow update, delete: if isAdmin();
    }

    /**
     * @description Controls access to Text-to-Speech (TTS) requests.
     * @path /ttsRequests/{requestId}
     * @allow (read) A user can only read their own TTS request records.
     * @allow (list) A user can only list their own TTS requests, not anyone else's.
     * @allow (create) A user can create a TTS request if it meets validation criteria (e.g., character limit).
     * @allow (update, delete) No one can update or delete TTS records to maintain a clear audit trail.
     * @principle Enforces ownership and abuse prevention through input validation.
     */
    match /ttsRequests/{requestId} {
      allow read: if isOwner(resource.data.userId);
      allow list: if isOwner(request.query.filters.userId); // Ensures users can only query their own requests.
      allow create: if isOwner(request.resource.data.userId) && hasValidTtsRequestCreateData(request.resource.data.userId);
      allow update, delete: if false; // Disallow modification to preserve history.
    }
  }
}
